#!/usr/bin/env ruby

require 'rubygems'
require 'docopt'
require 'volley'
require 'daemons'

DOC = <<-DOC
Usage: volley [options] <plan> <descriptor> [argument]...

<plan>
  The plan to run. This can be just the plan name or the project:plan.
  (will check in the reserved volley project for plan first)

<descriptor>
  A descriptor should conform to the following format:
    <project>[@<branch>[:<version>]]

  project:  the project name.
  branch:   the branch name.
            Defaults to the branch currently in use,
            must be specified for remote mode.
  version:  the version (revision)
            Defaults to the current revision
            In remote mode, defaults to "latest"

<argument>
  A list of key=value pairs

Options:
  -h --help           show this help message and exit
     --version        show version and exit
  -d --debug          change log level to debug
  -q --quiet          change log level to warn (generally this means no output)
  -c --config FILE    load additional Volleyfile [default: ~/.Volleyfile]
  -p --primary FILE   load primary Volleyfile [default: ./Volleyfile]
  -F --force          force operations (redeploy version, republish artifact)

  -f --fork           fork process into background and exit
  -l --log LOG        log file [default: /opt/volley/volley.log]
  -L --level LEVEL    log level [default: debug]
DOC

module Volley
  class Command
    def initialize
    end

    def run(argv)
      STDOUT.sync = true
      options     = Docopt::docopt(DOC, :version => Volley::Version::STRING)
      debug       = options[:debug]
      quiet       = options[:quiet]
      config      = options[:config]
      primary     = options[:primary]
      fork        = options[:fork]
      log         = options[:log]
      level       = options[:level]
      force       = options[:force]
      args        = { }


      Volley::Dsl::VolleyFile.init
      Volley::Dsl::VolleyFile.load(config, :optional => true)
      Volley::Dsl::VolleyFile.load(primary, :primary => true) if File.file?(primary)

      Volley.config.debug = debug
      Volley.config.quiet = quiet

      Volley::Log.add(level.to_sym, log)
      if debug
        Volley::Log.console_debug
      elsif quiet
        Volley::Log.console_quiet
      end

      kvs = argv.select { |e| e.match(/(\w+)\=(\w+)/) }
      pos = argv.reject { |e| e.match(/(\w+)\=(\w+)/) }

      plan = pos.shift
      desc = pos.shift

      raise "must specify plan" unless plan
      if plan =~ /\:/

      elsif Volley::Dsl.project(:volley).plan?(plan)
        # the plan is reserved
        plan = "volley:#{plan}"
      else
        # the plan isn't reserved
        raise "must specify descriptor" unless desc
        (project, branch, version) = Volley::Descriptor.new(desc).get
        plan                       = "#{project}:#{plan}"
      end

      args         = kvs.inject({ }) { |h, e| (k, v) = e.split(/=/); h[k.to_sym] = v; h }
      args[:force] = force

      if debug
        Volley::Log.debug "## OPTIONS ##"
        Volley::Log.debug "plan:       #{plan}"
        Volley::Log.debug "descriptor: #{desc}"
        Volley::Log.debug "positional: #{pos.join(",")}"
        Volley::Log.debug "key:value:  #{kvs.join(",")}"
      end

      if fork
        options = {
            :appname    => "volley",
            :dir        => Volley.config.directory,
            :dir_mode   => :normal,
            :log_output => true,
            :ontop      => false
        }
        Volley::Log.info "daemonizing ... "
        Volley::Log.reset
        Daemons.daemonize(options)
        Volley::Log.init
        Volley::Log.add(level.to_sym, log)
        Volley::Log.console_debug if debug
      end

      Volley.process(plan, desc, args)
    rescue Interrupt
      Volley::Log.info "interrupted"
    rescue SystemExit
      Volley::Log.debug "exited"
    rescue Docopt::Exit => e
      Volley::Log.info "volley version: #{e.message}"
    rescue => e
      Volley::Log.error "error: #{e} #{e.message} at #{e.backtrace.first}"
      Volley::Log.debug e
    end
  end
end

Volley::Command.new.run(ARGV)